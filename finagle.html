<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Scala School - An introduction to Finagle</title>
    <meta name="description" content="">
    <meta name="author" content="">

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <!-- Le styles -->
    <link rel="stylesheet" href="bootstrap-1.1.0.min.css">

  </head>

  <body>
  
    <div class="topbar">
      <div class="fill">
        <div class="container fixed">
          <h3><a href="index.html">An introduction to Finagle</a></h3>
          <ul class="nav secondary-nav">
            
              <li><a href="java.html">&laquo;Previous</a></li>
            
            
              <li><a href="searchbird.html">Next&raquo;</a></li>
            
          </ul>

        </div>
      </div>
    </div>

    <div class="container" style="padding-top: 60px;">
      <p><a href="https://github.com/twitter/finagle">Finagle</a> is Twitter&#8217;s <span class="caps">RPC</span> system. <a href="http://engineering.twitter.com/2011/08/finagle-protocol-agnostic-rpc-system.html">This</a> blog post explains its motivations and core design tenets, the <a href="https://github.com/twitter/finagle/blob/master/README.md">finagle <span class="caps">README</span></a> contains more detailed documentation. Finagle aims to make it easy to build robust clients and servers.</p>
<h2>Futures</h2>
<p>Finagle uses <code>com.twitter.util.Future</code><sup class="footnote" id="fnr1"><a href="#fn1">1</a></sup> to express delayed operations. Futures are highly expressive and composable, allowing for the succinct expression of concurrent and sequential operations with great clarity. Futures are a handle for a value not yet available, with methods to register callbacks to be invoked when the value becomes available. They invert the &#8220;traditional&#8221; model of asynchronous computing which typically expose APIs similar to this:</p>
<pre>
Callback&lt;R&gt; cb = new Callback&lt;R&gt;() {
  void onComplete(R result) { … }
  void onFailure(Throwable error) { … }
}

dispatch(req, cb);
</pre>
<p>Here, the <code>Callback.onComplete</code> is invoked when the result of the <code>dispatch</code> operation is available, and <code>Callback.onFailure</code> if the operation fails. With futures, we instead invert this control flow:</p>
<pre>
val future = dispatch(req)
future onSuccess { value =&gt; … }
future onFailure { error =&gt; … }
</pre>
<p>Futures themselves have combinators similar to those we&#8217;ve encountered before in the various collections APIs. Combinators work by exploiting a uniform <span class="caps">API</span>, wrapping some underlying <code>Future</code> with new behavior without modifying that underlying <code>Future</code>.</p>
<h3>Sequential composition</h3>
<p>The most important <code>Future</code> combinator is <code>flatMap</code><sup class="footnote" id="fnr2"><a href="#fn2">2</a></sup>:</p>
<blockquote>
<p><code>def Future[A].flatMap[B](f: A =&gt; Future[B]): Future[B]</code></p>
</blockquote>
<p><code>flatMap</code> sequences two features. The method signature tells the story: given the succesful value of the future <code>f</code> must provide the next <code>Future</code>. The result of this operation is another <code>Future</code> that is complete only when both of these futures have completed. If either <code>Future</code> fails, the given <code>Future</code> will also fail. This implicit interleaving of errors allow us to handle errors only in those places where they are semantically significant. <code>flatMap</code> is the standard name for the combinator with these semantics. Scala also has syntactic shorthand to invoke it: the <code>for</code> comprehension.</p>
<p>As an example, let&#8217;s assume we have methods <code>authenticate: Request -&gt; User</code>, and <code>rateLimit: User -&gt; Boolean</code>, then the following code:</p>
<pre>
val f = for {
  u &lt;- authenticate(request)
  r &lt;- rateLimit(u)
} yield (u, r)
</pre>
<p>produces a future <code>f: Future[(User, Boolean)]</code> that provides both the user object and and a boolean indicating whether that user has been rate limited. Note how sequential composition is required here: <code>rateLimit</code> takes as an argument the output of <code>authenticate</code></p>
<h3>Concurrent composition</h3>
<p>There are also a number of concurrent combinators. Generally these convert a sequence of <code>Future</code> into a <code>Future</code> of sequence, in slightly different ways:</p>
<pre>
object Future {
  …
  def collect[A](fs: Seq[Future[A]]): Future[Seq[A]]
  def join(fs: Seq[Future[_]]): Future[Unit]
  def select(fs: Seq[Future[A]]) : Future[(Try[A], Seq[Future[A]])]
}
</pre>
<p><code>collect</code> is the most straightforward one: given a set of <code>Future</code>s of the same type, we are given a <code>Future</code> of a sequence of values of that type. This future is complete when all of the underlying futures have completed, or when any of them have failed.</p>
<p><code>join</code> takes a sequence of <code>Future</code>s whose types may be mixed, yielding a <code>Future[Unit]</code> that is completely when all of the underlying futures are (or fails if any of them do). This is useful for indicating the completion of a set of heterogeneous operations.</p>
<p><code>select</code> returns a <code>Future</code> that is complete when the first of the given <code>Future</code>s complete, together with the remaining uncompleted futures.</p>
<p>In combination, this allows for powerful and concise expression of operations typical of network services. This hypothetical code performs rate limiting (in order to maintain a local rate limit cache) concurrently with dispatching a request on behalf of the user to the backend:</p>
<pre>
def serve(request: Request): Future[Response] = {
  val userLimit: Future[(User, Boolean)] =
    for {
      user    &lt;- auth(request)
      limited &lt;- isLimit(user)
    } yield (user, limited)
  
  val done = 
    dispatch(request) join userLimit
  
  done flatMap { case (rep, (usr, lim)) =&gt;
    if (lim) {
      updateLocalRateLimitCache(usr)
      Future.exception(new Exception("rate limited"))
    } else {
      Future.value(rep)
    }
  }
}
</pre>
<p>This hypothetical example combines both sequential and concurrent composition. Also note how there is no explicit error handling other than converting a rate limiting reply to an exception. If any future fails here, it is automatically propagated to the returned <code>Future</code>.</p>
<h2>Service</h2>
<p>A <code>Service</code> is a function <code>Req =&gt; Future[Rep]</code> for some request and reply types. <code>Service</code> is used by both clients and servers: servers implement <code>Service</code> and clients use builders to create one used for querying.</p>
<blockquote>
<p><code>abstract class Service[-Req, +Rep] extends (Req =&gt; Future[Rep])</code></p>
</blockquote>
<p>A simple <span class="caps">HTTP</span> client might do:</p>
<pre>
service: Service[HttpRequest, HttpResponse]

val f = service(HttpRequest("/", HTTP_1_1))
f onSuccess { res =&gt;
  println("got response", res)
} onFailure { exc =&gt;
  println("failed :-(", exc)
}
</pre>
<p>Servers implement <code>Service</code>:</p>
<pre>
class MyServer 
  extends Service[HttpRequest, HttpResponse]
{
  def apply(request: HttpRequest) = {
    request.path match {
      case "/" =&gt; 
        Future.value(HttpResponse("root"))
      case _ =&gt; 
        Future.value(HttpResponse("default"))
    }
  }
}
</pre>
<p>Combining them is easy. A simple proxy might look like this:</p>
<pre>
class MyServer(client: Service[..])
  extends Service[HttpRequest, HttpResponse]
{
  def apply(request: HttpRequest) = {
    client(rewriteReq(request)) map { res =&gt;
      rewriteRes(res)
    }
  }
}
</pre>
<p>where <code>rewriteReq</code> and <code>rewriteRes</code> can provide protocol translation, for example.</p>
<h2>Filters</h2>
<p>Filters are service transformers. They are useful both for providing functionality that&#8217;s <em>service generic</em> as well as factoring a given service into distinct phases.</p>
<pre>
abstract class Filter[-ReqIn, +RepOut, +ReqOut, -RepIn]
  extends ((ReqIn, Service[ReqOut, RepIn]) =&gt; Future[RepOut])
</pre>
<p>Its type is better viewed diagramatically:</p>
<pre>
    ((ReqIn, Service[ReqOut, RepIn]) 
         =&gt; Future[RepOut])


           (*   Service   *)
[ReqIn -&gt; (ReqOut -&gt; RepIn) -&gt; RepOut]
</pre>
<p>Here&#8217;s how you might write a filter that provides a service timeout mechanism.</p>
<pre>
class TimeoutFilter[Req, Rep](
    timeout: Duration, timer: util.Timer)
  extends Filter[Req, Rep, Req, Rep]
{
  def apply(
    request: Req, service: Service[Req, Rep]
  ): Future[Rep] = {
    service(request).timeout(timer, timeout) {
      Throw(new TimedoutRequestException)
    }
  }
}
</pre>
<p>This example shows how you might provide authentication (via an authentication service) in order to convert a <code>Service[AuthHttpReq, HttpRep]</code> into <code>Service[HttpReq, HttpRep]</code>.</p>
<pre>
class RequireAuthentication(passbird: Passbird)
  extends Filter[HttpReq, HttpRep, AuthHttpReq, HttpRep]
{
  def apply(
    req: HttpReq, 
    service: Service[AuthHttpReq, HttpRep]
  ) = {
    authService.auth(req) flatMap {
      case AuthResult(AuthResultCode.OK, Some(passport), _) =&gt;
        service(AuthHttpReq(req, passport))
      case ar: AuthResult =&gt;
        Trace.record("Passbird authentication failed with " + ar)
        Future.exception(
          new RequestUnauthenticated(ar.resultCode))
    }
  }
}
</pre>
<p>Filters compose together with <code>andThen</code>. Providing a <code>Service</code> as an argument to <code>andThen</code> creates a (filtered) <code>Service</code> (types provided for illustration).</p>
<pre>
val authFilter: Filter[HttpReq, HttpRep, AuthHttpReq, HttpRep]
val timeoutfilter[Req, Rep]: Filter[Req, Rep, Req, Rep]
val serviceRequiringAuth: Service[AuthHttpReq, HttpRep]

val authenticateAndTimedOut: Filter[HttpReq, HttpRep, AuthHttpReq, HttpRep] =
  authFilter andThen timeoutFilter

val authenticatedTimedOutService: Service[HttpReq, HttpRep] =
  authenticateAndTimedOut andThen serviceRequiringAuth
</pre>
<h2>Builders</h2>
<p>Finally, builders put it all together. A <code>ClientBuilder</code> produces a <code>Service</code> instance given a set of parameters, and a <code>ServerBuilder</code> takes a <code>Service</code> instance and dispatches incoming requests on it. In order to determine the type of <code>Service</code>, we must provide a <code>Codec</code>. Codecs provide the underlying protocol implementation (eg. <span class="caps">HTTP</span>, thrift, memcached). Both builders have many parameters, and require a few.</p>
<p>Here&#8217;s an example <code>ClientBuilder</code> invocation (types provided for illustration):</p>
<pre>
val client: Service[HttpRequest, HttpResponse] = ClientBuilder()
  .codec(Http)
  .hosts("host1.twitter.com:10000,host2.twitter.com:10001,host3.twitter.com:10003")
  .hostConnectionLimit(1)
  .tcpConnectTimeout(1.second)
  .retries(2)
  .reportTo(new OstrichStatsReceiver)
  .build()
</pre>
<p>This builds a client that load balances over the 3 given hosts, establishing at most 1 connection per host, and giving up only after 2 failures. Stats are reported to <a href="https://github.com/twitter/ostrich">ostrich</a>. The following builder options are required (and their presence statically enforced): <code>hosts</code> or <code>cluster</code>, <code>codec</code> and <code>hostConnectionLimit</code>.</p>
<pre>
val myService: Service[HttpRequest, HttpResponse] = // provided by the user
ServerBuilder()
  .codec(Http)
  .hostConnectionMaxLifeTime(5.minutes)
  .readTimeout(2.minutes)
  .name("myHttpServer")
  .bindTo(new InetSocketAddress(serverPort))
  .build(myService)
</pre>

<p>This will serve, on port <code>serverPort</code> an <span class="caps">HTTP</span> server which dispatches requests to <code>myService</code>. Each connection is allowed to stay alive for up to 5 minutes, and we require a request to be sent within 2 minutes. The required <code>ServerBuilder</code> options are: <code>name</code>, <code>bindTo</code> and <code>codec</code>.</p>
<p class="footnote" id="fn1"><a href="#fnr1"><sup>1</sup></a> distinct from <code>java.util.concurrent.Future</code></p>
<p class="footnote" id="fn2"><a href="#fnr2"><sup>2</sup></a> this is equivalent to a monadic bind</p>
    </div> <!-- /container -->

    <div id="footer">
      <div class="inner">
        <div class="container">
          <p>
            Built at <a href="http://twitter.com/twitter" target="_blank">@twitter</a> by <a href="http://twitter.com/stevej" target="_blank">@stevej</a> and <a href="http://twitter.com/marius" target="_blank">@marius</a> with much help from <a href="http://twitter.com/evanm" target="_blank">@evanm</a>, <a href="http://twitter.com/sprsquish" target="_blank">@sprsquish</a>, <a href="http://twitter.com/kevino" target="_blank">@kevino</a>, <a href="http://twitter.com/zuercher" target="_blank">@zuercher</a>, <a href="http://twitter.com/timtrueman" target="_blank">@timtrueman</a>, <a href="http://twitter.com/wickman" target="_blank">@wickman</a> and <a href="http://twitter.com/mccv" target="_blank">@mccv</a><br />
            Licensed under the <a href="http://www.apache.org/licenses/LICENSE-2.0" target="_blank">Apache License v2.0</a>.
          </p>
        </div>
      </div>
    </div>

  </body>
</html>
